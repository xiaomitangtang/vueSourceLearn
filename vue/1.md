### Vue

```
  simple 中的vue 类似vue  1 的简版，由于挂载太多的watcher，项目大了，watcher太多
  导致卡顿，所以vue1  不适合做大项目
  2之后 每一个组件一个watcher，并且引入虚拟dom  进行优化


```

```
Object.isExtensible(obj)    是否是可扩展（在上面添加属性等操作）

instance/init
<!-- init中处理顺序 -->
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

initState中处理了事件，属性响应式
    vue中的data为函数时，尝试执行，并传入一个参数为vm，就是Vue实例
    data 只能是纯对象，  通过isPlainObject  判断
    在initData之前，先初始化props以及methods，所以可以访问到props，methds,
    之后初始化 computed  以及 watch

<!-- state.js -->
      if (opts.props) initProps(vm, opts.props)
      if (opts.methods) initMethods(vm, opts.methods)
      if (opts.data) {
        initData(vm)
      } else {
        observe(vm._data = {}, true /* asRootData */)
      }
  初始化data时，将所有属性  proxy到vm上
  然后observe  data（建立响应式）

    Observer  ，包裹数组的异构（会改变原数组）的方法，并递归数组以及对象
    Object.defineProperty进行响应拦截，（闭包！！！，
    并未改变原引用？通过setter.call，在闭包内直接返回value，
    实际是改变了引用对象的）
    dep中存储watcher，watcher中也存储dep（多对多..）
      在事件序列中增加watcher
    在get中添加watcher，在set中触发 dep的notify
      中存储dep  【依赖项管理】
      update中依次 update  watcher

      watcher中的update 实际是执行  queueWatcher
      queueWatcher调用nextTick以及在  flushSchedulerQueue
      在所有watcher执行完之后
      resetSchedulerState()
      以此循环
      nextTick  依次使用  Promise MutationObserver setImmediate  setTimeout进行兼容处理
<!-- nextTick尝试使用微任务进行批量处理，为了兼容，降级使用 setImmediate setTimeout进行兼容处理-->

js执行顺序，js栈，微任务，宏任务
  在宏任务中，微任务可以继续创建微任务，依旧是js栈，微任务，宏任务顺序
  使用微任务可以在浏览器刷新之前处理完所有变更，已达到无感知的目的

  注意：
    new Promise（r=>{
      code1
    }）.then(code2).then(code3)
  code1  是同步代码，then中的code2才是异步代码
  code3需要等到code2执行完之后，才执行的下一个微任务
```
